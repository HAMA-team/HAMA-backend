# Phase 1 MVP 구현 계획 - 전체 개요

**버전**: 1.0
**작성일**: 2025-10-01
**기반 문서**: PRD v1.2, 에이전트 아키텍쳐 v2.0

---

## 목차

1. [Phase 1 목표](#phase-1-목표)
2. [Mock-First 접근 전략](#mock-first-접근-전략)
3. [제외 사항](#제외-사항)
4. [구현 단계 요약](#구현-단계-요약)
5. [성공 기준](#성공-기준)

---

## Phase 1 목표

### 핵심 목표
**"전체 투자 프로세스 플로우가 원활하게 작동하는 MVP 완성"**

- ✅ 사용자가 Chat 인터페이스로 투자 의사결정 가능
- ✅ 9개 핵심 에이전트 동작 (Mock → 실제 구현)
- ✅ HITL(Human-in-the-Loop) 개입 시스템 작동
- ✅ 3단계 자동화 레벨 지원
- ✅ 실제 데이터 소스 연동 (DART, 한국투자증권, 네이버 금융)

### 제공 기능

| 기능 | 설명 | 우선순위 |
|-----|------|---------|
| **종목 분석** | 재무제표, 기술적 지표, Bull/Bear 분석 | P0 |
| **매매 추천** | 매수/매도 시그널 생성 및 HITL 승인 | P0 |
| **포트폴리오 구성** | 자산 배분 최적화 및 리밸런싱 제안 | P0 |
| **리스크 평가** | 집중도 리스크, VaR 계산, 경고 | P0 |
| **실시간 모니터링** | 가격 추적, 이벤트 감지 (명시적 요청) | P1 |
| **교육/질의** | 투자 용어 설명, 시장 해설 | P1 |

---

## Mock-First 접근 전략

### 전략 개요

**"일단 전체 흐름부터 검증하고, 우선순위에 따라 실제 구현"**

### 왜 Mock-First인가?

1. **빠른 플로우 검증**: 전체 시스템 아키텍처의 타당성을 조기에 확인
2. **병렬 작업 가능**: 프론트엔드와 백엔드 팀이 동시에 작업
3. **요구사항 조기 발견**: Mock 데이터로 UX 테스트하며 개선점 파악
4. **리스크 감소**: 복잡한 구현 전에 설계 오류 수정

### Mock 구현 원칙

```python
# 모든 에이전트는 이 패턴을 따름

class SomeAgent:
    async def process(self, input: AgentInput) -> AgentOutput:
        # TODO: 실제 구현 필요
        # - [ ] DART API 연동
        # - [ ] 재무제표 분석 로직
        # - [ ] 캐싱 전략

        # Mock 데이터 반환
        return self._get_mock_response(input)

    def _get_mock_response(self, input: AgentInput) -> AgentOutput:
        """Mock 데이터 생성 - 실제 응답 포맷과 동일"""
        return AgentOutput(
            status="success",
            data=mock_data[input.ticker],
            metadata={"source": "mock"}
        )
```

### Mock → 실제 구현 전환

**우선순위 기반 점진적 전환**

```
1단계 (2주): 모든 에이전트 Mock 완성
     ↓
2단계 (2주): E2E 플로우 검증
     ↓
3단계 (8주): P0 에이전트 실제 구현
     - 데이터 수집 (1-2주)
     - 리서치 (2주)
     - 전략 (3주)
     - 포트폴리오 (3주)
     - 리스크 (2주)
     ↓
4단계 (2주): P1 에이전트 실제 구현
     - 모니터링 (2주)
     - 교육/질의 (1주)
```

---

## 제외 사항

### Redis 제외 결정

**결정**: Phase 1에서는 Redis 사용하지 않음

**이유**:
- MVP에서는 간단한 메모리 캐싱으로 충분
- 복잡도 증가 대비 효과 미미
- 단일 사용자 환경 가정

**대안**:
```python
# Python functools.lru_cache 사용
from functools import lru_cache

@lru_cache(maxsize=128)
def get_stock_data(ticker: str, date: str):
    # API 호출
    pass
```

**Phase 2에서 도입 고려**:
- 다중 사용자 지원 시
- 실시간 데이터 스트리밍 필요 시
- 에이전트 간 비동기 메시징 필요 시

### 기타 제외 항목

| 항목 | 이유 | 도입 시기 |
|-----|------|----------|
| **실제 매매 실행** | 법적/기술적 리스크 | Phase 2 |
| **사용자 계정 시스템** | MVP 불필요 | Phase 2 |
| **실시간 Push 알림** | 복잡도 높음 | Phase 2 |
| **백테스팅** | 핵심 기능 아님 | Phase 2 |
| **감정 분석** | 부가 기능 | Phase 3 |

---

## 구현 단계 요약

### 1단계: 기본 인프라 (2주)

**목표**: 프로젝트 기반 마련

- FastAPI 프로젝트 구조
- PostgreSQL 스키마 설계
- LangGraph 초기화
- 기본 API 엔드포인트

**결과물**:
- `src/` 디렉터리 구조
- `requirements.txt`
- 기본 CRUD API
- LangGraph StateGraph 템플릿

---

### 2단계: 마스터 에이전트 Mock (2주)

**목표**: 오케스트레이션 로직 구현

**구현 내용**:
- 의도 분석 (7가지 카테고리)
- 라우팅 로직
- HITL 트리거 판단
- Mock Response Generator

**검증**:
- [ ] "삼성전자 분석해줘" → research + strategy 호출
- [ ] "삼성전자 매수" → HITL 트리거 발동
- [ ] 자동화 레벨별 다른 응답

---

### 3단계: 핵심 에이전트 Mock (3주)

**목표**: 9개 에이전트 기본 구조 완성

**구현 에이전트**:
1. 개인화 에이전트
2. 데이터 수집 에이전트
3. 리서치 에이전트
4. 전략 에이전트
5. 포트폴리오 에이전트
6. 리스크 에이전트
7. 모니터링 에이전트
8. 교육/질의 에이전트

**각 에이전트**:
- 기본 인터페이스 구현
- Mock 데이터 반환
- TODO 주석으로 실제 구현 명시

---

### 4단계: E2E 플로우 검증 (2주)

**목표**: 전체 시스템 통합 테스트

**테스트 시나리오**:

#### 시나리오 1: 종목 분석
```
사용자: "삼성전자 분석해줘"
     ↓
마스터 → 리서치 + 전략 + 리스크 (병렬)
     ↓
통합 응답 생성
     ↓
"📊 삼성전자 분석 결과..."
```

#### 시나리오 2: 매매 지시 (HITL)
```
사용자: "삼성전자 1000만원 매수"
     ↓
전략 → 리스크 체크 → 경고 발생
     ↓
HITL 트리거
     ↓
"⚠️ 집중도 리스크 경고... [취소] [수정] [진행]"
```

#### 시나리오 3: 포트폴리오 리밸런싱
```
사용자: "포트폴리오 리밸런싱"
     ↓
포트폴리오 에이전트 → 리밸런싱안 생성
     ↓
자동화 레벨별 승인 옵션
     ↓
Lv1: [수용] [거부]
Lv2: [수용] [보수적] [공격적]
Lv3: 상세 조정 UI
```

**검증 기준**:
- [ ] 모든 시나리오가 에러 없이 완료
- [ ] HITL 트리거가 올바른 시점에 발동
- [ ] 자동화 레벨별 다른 동작
- [ ] 에이전트 간 메시지 전달 정상

---

### 5단계: 실제 구현 - 데이터 레이어 (2주)

**목표**: 데이터 수집 에이전트 완성

**구현 순서**:

1. **pykrx 연동** (1일)
   - 주가 데이터
   - 시장 데이터

2. **DART API 연동** (2-3일)
   - OpenDartReader 설치
   - 재무제표 조회
   - 공시 조회

3. **한국투자증권 API 연동** (3-4일)
   - pykis 설치
   - 실시간 시세
   - 호가 데이터

4. **네이버 금융 크롤링** (3일)
   - INVESTAR 코드 참고
   - 뉴스 크롤링
   - User-Agent 처리

5. **캐싱 전략** (2일)
   - lru_cache 적용
   - 캐시 만료 로직

**결과물**:
- `src/api/` 디렉터리 완성
- 통합 테스트 통과
- API 레이트 리밋 관리

---

### 6단계: 실제 구현 - 분석 레이어 (6주)

**목표**: P0 에이전트 실제 구현

**구현 순서** (우선순위):

#### 6-1. 리서치 에이전트 (2주)
- 재무제표 분석 로직
- 기술적 지표 (TA-Lib)
- 산업/경쟁사 비교

#### 6-2. 전략 에이전트 (3주)
- Bull/Bear 서브에이전트
- 종목 스크리닝
- 매매 시그널 생성

#### 6-3. 포트폴리오 에이전트 (3주)
- 자산 배분 최적화
- 샤프 비율 최대화
- 리밸런싱 알고리즘

#### 6-4. 리스크 에이전트 (2주)
- VaR 계산
- 집중도 리스크 체크
- 손실 시뮬레이션

#### 6-5. 모니터링 에이전트 (2주)
- 가격 추적
- 이벤트 감지

#### 6-6. 개인화 & 교육 에이전트 (1주)
- 프로필 관리
- 용어 설명 DB

**병렬 작업 가능**:
- 리서치 + 포트폴리오 (의존성 없음)
- 리스크 + 모니터링 (의존성 없음)

---

## 성공 기준

### MVP 완성 조건

| 기준 | 목표 | 측정 방법 |
|-----|------|----------|
| **기능 완성도** | 9개 에이전트 100% 구현 | 체크리스트 |
| **E2E 테스트** | 3가지 핵심 플로우 통과 | 자동화 테스트 |
| **응답 속도** | 평균 < 3초 | 로그 분석 |
| **데이터 정확성** | API 연동 에러 < 5% | 에러 로그 |
| **HITL 정확성** | 트리거 오작동 < 5% | 수동 테스트 |

### Phase 1 → Phase 2 이행 조건

- [ ] 5명 이상 베타 테스터 테스트 완료
- [ ] 만족도 80% 이상
- [ ] 치명적 버그 0건
- [ ] 문서화 100% (API 문서, 사용 가이드)

---

## 다음 단계

**Phase 1 완료 후**:

1. **Phase 2 기획**
   - 실제 매매 실행
   - 사용자 계정 시스템
   - 백테스팅
   - 실시간 알림

2. **성능 최적화**
   - Redis 도입
   - 비동기 처리 개선
   - 응답 속도 < 1초

3. **UI/UX 개선**
   - 프론트엔드 고도화
   - 모바일 최적화

---

**문서 끝**

**관련 문서**:
- [데이터 소스 통합 가이드](./data-sources-integration.md)
- [에이전트 구현 상세](./agent-implementation-details.md)
- [기술 스택 설정](./tech-stack-setup.md)
- [타임라인](./timeline-phase1.md)